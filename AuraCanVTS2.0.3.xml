<?xml version="1.0"?>
<TriggernometryExport PluginVersion="1.2.0.6">
  <ExportedFolder Id="510ae4a5-95ac-449a-8677-c773dd4c79b0" Name="AuraCanVTS2.0" Enabled="true">
    <Folders />
    <Triggers>
      <Trigger Enabled="true" Source="FFXIVNetwork" Name="AuraCanVTS2.0注册" Id="15f30061-9309-42b6-8890-99b0f8b6cf57" RegularExpression="^253\|">
        <Actions>
          <Action OrderNumber="1" ExecScriptExpression="using System;&#xD;&#xA;using System.Collections.Concurrent;&#xD;&#xA;using System.Collections.Generic;&#xD;&#xA;using System.Linq;&#xD;&#xA;using System.Text.RegularExpressions;&#xD;&#xA;using System.Threading;&#xD;&#xA;using System.Windows.Forms;&#xD;&#xA;using Triggernometry;&#xD;&#xA;using Triggernometry.Variables;&#xD;&#xA;using WebSocketSharp;&#xD;&#xA;using static Triggernometry.Interpreter;&#xD;&#xA;&#xD;&#xA;public const string wsUrl = &quot;ws://127.0.0.1:8001&quot;; // API地址&#xD;&#xA;public const string pluginName = &quot;AuraCanVTS&quot;; // 插件名称，同时也是日志关键词&#xD;&#xA;public const string version = &quot;2.0.3&quot;; // 插件版本&#xD;&#xA;public const string developer = &quot;纤凌依 &amp; MnFeN&quot;; // 作者&#xD;&#xA;// 插件图标 pluginIcon&#xD;&#xA;AuraCanVTS.Init(&quot;abcde&quot;);&#xD;&#xA;&#xD;&#xA;public static class AuraCanVTS {&#xD;&#xA;	private static Schedular _schedular;//定时任务&#xD;&#xA;	private static Dictionary&lt;string, Handle&gt; _handles;//玩家日志行处理器列表&#xD;&#xA;	private static Dictionary&lt;string, Handle&gt; _anyHandles;//任意实体日志行处理器列表&#xD;&#xA;	private static VariableDictionary _dv;//持久变量&#xD;&#xA;	private static string _playerId;//当前玩家Id&#xD;&#xA;&#xD;&#xA;	//被用作回调函数,仅处理start/stop/press&#xD;&#xA;	private static void Sender(string type, string command)&#xD;&#xA;	{&#xD;&#xA;		Dictionary&lt;string, object&gt; strAndPar = CheckCmd(type, command);&#xD;&#xA;		Dictionary&lt;string, object&gt; parameters = (Dictionary&lt;string, object&gt;)strAndPar[&quot;parameters&quot;];&#xD;&#xA;		string longCmdStr = (string)strAndPar[&quot;longCmdStr&quot;];&#xD;&#xA;		Message msg = new Message(parameters);&#xD;&#xA;		AuraCanSocket.SendToVTubeStudio(msg.Serialize());&#xD;&#xA;		Logger.Log2(longCmdStr);&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;	//该方法仅处理99行以内的网络日志&#xD;&#xA;	public static void LogProcess(object _, string logString)&#xD;&#xA;	{&#xD;&#xA;		string handleNo = logString.Substring(0, 2);&#xD;&#xA;		//默语指令处理&#xD;&#xA;		if(handleNo == &quot;00&quot; &amp;&amp; logString.Substring(37, 4) == &quot;0038&quot; &amp;&amp; logString.Substring(43, 4) == &quot;vts &quot;)&#xD;&#xA;		{&#xD;&#xA;			string commandStr = logString.Substring(43, logString.LastIndexOf('|') - 43);//原始指令&#xD;&#xA;			string longCommandStr = &quot;&quot;;//处理后的指令(长)&#xD;&#xA;			string shortCommandStr = &quot;&quot;;//处理后的指令(短)&#xD;&#xA;			Dictionary&lt;string, object&gt; parameters;//处理后的参数&#xD;&#xA;			CommandTypeEnum commandType = CheckCommand(commandStr, out longCommandStr, out shortCommandStr,out parameters);&#xD;&#xA;			Logger.Log2($&quot;commandType:{commandType.ToString()}&quot;);&#xD;&#xA;			Logger.Log($&quot;command:{longCommandStr}&quot;);&#xD;&#xA;			switch (commandType) {&#xD;&#xA;				case CommandTypeEnum.createparameter://创建新参数&#xD;&#xA;				case CommandTypeEnum.deleteparameter://删除参数&#xD;&#xA;				case CommandTypeEnum.executecommand://执行指令&#xD;&#xA;					AuraCanSocket.SendToVTubeStudio(new Message(parameters).Serialize());&#xD;&#xA;					break;&#xD;&#xA;				case CommandTypeEnum.createcommand://保存指令&#xD;&#xA;					VtsSaveCommand(shortCommandStr);&#xD;&#xA;					break;&#xD;&#xA;				case CommandTypeEnum.deletecommand://删除指令&#xD;&#xA;					VtsDeleteCommand(parameters);&#xD;&#xA;					break;&#xD;&#xA;				case CommandTypeEnum.showcommand://列出指令&#xD;&#xA;					VtsShowCommand();&#xD;&#xA;					break;&#xD;&#xA;				case CommandTypeEnum.schedular://定时器&#xD;&#xA;					VtsCreateSchedular(shortCommandStr, parameters);&#xD;&#xA;					break;&#xD;&#xA;				case CommandTypeEnum.changeLog://改变日志级别&#xD;&#xA;					Logger.SetLogger((string)parameters[&quot;level&quot;]);&#xD;&#xA;					break;&#xD;&#xA;				case CommandTypeEnum.donothing:&#xD;&#xA;					Logger.Log(&quot;do nothing&quot;);&#xD;&#xA;					break; //无匹配&#xD;&#xA;			}&#xD;&#xA;		}&#xD;&#xA;		else&#xD;&#xA;		{&#xD;&#xA;			bool playerFlag = _handles.ContainsKey(handleNo);&#xD;&#xA;			bool anyFlag = _anyHandles.ContainsKey(handleNo);&#xD;&#xA;			if(playerFlag || anyFlag)&#xD;&#xA;			{&#xD;&#xA;				logString = logString.Substring(37);&#xD;&#xA;				string[] log = logString.Split('|');&#xD;&#xA;				if(playerFlag)&#xD;&#xA;				{&#xD;&#xA;					_handles[handleNo].HandleProcess(_playerId, log);&#xD;&#xA;				}&#xD;&#xA;				if(anyFlag)&#xD;&#xA;				{&#xD;&#xA;					_anyHandles[handleNo].HandleProcess(_playerId, log);&#xD;&#xA;				}&#xD;&#xA;			}&#xD;&#xA;		}&#xD;&#xA;		if(handleNo == &quot;02&quot;)//更新当前玩家的名称和ID(可能会有更换模型的动作,因此不作为elseif)&#xD;&#xA;		{&#xD;&#xA;			_playerId = logString.Split('|')[2];&#xD;&#xA;			StaticHelpers.SetScalarVariable(true, $&quot;{pluginName}PlayerId&quot;, _playerId);&#xD;&#xA;			Logger.Log2($&quot;player {_playerId}&quot;);&#xD;&#xA;		}&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;	//初始化Handles&#xD;&#xA;	public static void InitHandles()&#xD;&#xA;	{&#xD;&#xA;		_handles = new Dictionary&lt;string, Handle&gt;();&#xD;&#xA;		_anyHandles = new Dictionary&lt;string, Handle&gt;();&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;	public static void Init(string steps)&#xD;&#xA;	{&#xD;&#xA;		//初始化类&#xD;&#xA;		if(steps.Contains(&quot;a&quot;))&#xD;&#xA;		{&#xD;&#xA;			InitHandles();//初始化Handles&#xD;&#xA;			string logLevel = StaticHelpers.GetScalarVariable(true, $&quot;{pluginName}LogLevel&quot;) ?? &quot;312&quot;;//日志级别,默认312&#xD;&#xA;			Logger.SetLogger(logLevel);&#xD;&#xA;			_playerId = StaticHelpers.GetScalarVariable(true, $&quot;{pluginName}PlayerId&quot;) ?? &quot;unknow&quot;;&#xD;&#xA;			Logger.Log2($&quot;[A]init handles finished,loglevel {logLevel},playerId {_playerId}&quot;);&#xD;&#xA;		}&#xD;&#xA;		//初始化websocket链接&#xD;&#xA;		if(steps.Contains(&quot;b&quot;))&#xD;&#xA;		{&#xD;&#xA;			AuraCanSocket.InitSocket();&#xD;&#xA;			Logger.Log2($&quot;[B]init websocket finished&quot;);&#xD;&#xA;		}&#xD;&#xA;		//初始化定时器&#xD;&#xA;		if(steps.Contains(&quot;c&quot;))&#xD;&#xA;		{&#xD;&#xA;			_schedular = new Schedular();&#xD;&#xA;			Logger.Log2($&quot;[C]init schedular finished&quot;);&#xD;&#xA;		}&#xD;&#xA;		//字符串还原回方法&#xD;&#xA;		if(steps.Contains(&quot;d&quot;))&#xD;&#xA;		{&#xD;&#xA;			_dv = StaticHelpers.GetDictVariable(true, pluginName);&#xD;&#xA;			if(_dv == null)&#xD;&#xA;			{&#xD;&#xA;				StaticHelpers.SetDictVariable(true, pluginName, new VariableDictionary());&#xD;&#xA;				_dv = StaticHelpers.GetDictVariable(true, pluginName);&#xD;&#xA;			}&#xD;&#xA;			else&#xD;&#xA;			{&#xD;&#xA;				foreach(var v in _dv.Values.Values)&#xD;&#xA;				{&#xD;&#xA;					string commandStr = v.ToString();&#xD;&#xA;					if(Regex.Match(commandStr, @&quot;^vts set&quot;).Success) //set&#xD;&#xA;					{&#xD;&#xA;						Logger.Log2($&quot;init schedular:{commandStr}&quot;);&#xD;&#xA;						CheckCommand(commandStr, out _, out _,out Dictionary&lt;string, object&gt; parameters);&#xD;&#xA;						VtsCreateSchedular(&quot;&quot;, parameters);&#xD;&#xA;					}&#xD;&#xA;					else //start/stop/press&#xD;&#xA;					{&#xD;&#xA;						Logger.Log2($&quot;init command:{commandStr}&quot;);&#xD;&#xA;						CheckCommand(commandStr, out _, out _,out Dictionary&lt;string, object&gt; parameters);&#xD;&#xA;					}&#xD;&#xA;				}&#xD;&#xA;			}&#xD;&#xA;			Logger.Log2($&quot;[D]init commands and schedulars finished,rebuild {_dv.Size} command(s)&quot;);&#xD;&#xA;		}&#xD;&#xA;		//注册回调函数&#xD;&#xA;		if(steps.Contains(&quot;e&quot;))&#xD;&#xA;		{&#xD;&#xA;			RealPlugin.plug.RegisterNamedCallback($&quot;{pluginName}&quot;, new Action&lt;object, string&gt;(LogProcess), null);&#xD;&#xA;			RealPlugin.plug.RegisterNamedCallback($&quot;{pluginName}StartSender&quot;, (object _, string command) =&gt; Sender(&quot;start&quot;, command), null);&#xD;&#xA;			RealPlugin.plug.RegisterNamedCallback($&quot;{pluginName}StopSender&quot;, (object _, string command) =&gt; Sender(&quot;stop&quot;, command), null);&#xD;&#xA;			RealPlugin.plug.RegisterNamedCallback($&quot;{pluginName}PressSender&quot;, (object _, string command) =&gt; Sender(&quot;press&quot;, command), null);&#xD;&#xA;			RealPlugin.plug.RegisterNamedCallback($&quot;{pluginName}JsonSender&quot;, (object _, string json) =&gt; AuraCanSocket.SendToVTubeStudio(json), null);//究极摆烂&#xD;&#xA;			Logger.Log2($&quot;[E]init callback functions finished&quot;);&#xD;&#xA;		}&#xD;&#xA;		Logger.Log2($&quot;init plugin finished&quot;);&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;	private static CommandTypeEnum CheckCommand(string commandStr, out string longCommandStr, out string shortCommandStr, out Dictionary&lt;string, object&gt; parameters)&#xD;&#xA;	{&#xD;&#xA;		Match match;&#xD;&#xA;		parameters = new Dictionary&lt;string, object&gt;();&#xD;&#xA;		/*&#xD;&#xA;			CommandTypeEnum.createparameter:&#xD;&#xA;				Adding new tracking parameters (&quot;custom parameters&quot;).Parameter names have to be unique, alphanumeric (no spaces allowed) and have to be between 4 and 32 characters in length.&#xD;&#xA;				添加新的跟踪参数（“自定义参数”）。参数名称必须是唯一的字母数字（不允许有空格），长度必须在4到32个字符之间。&#xD;&#xA;			eg:&#xD;&#xA;				vts create new parameter ParamBodyAngleX with maximum value 20, minimum value 10, default value 15, and notes that the parameter is optional&#xD;&#xA;				vts create new parameter ParamBodyAngleX with maximum value 20, minimum value 10, default value 15&#xD;&#xA;				vts new par ParamBodyAngleX 20 10 15 note the parameter is optional&#xD;&#xA;				vts new par ParamBodyAngleX 20 10 15&#xD;&#xA;		*/&#xD;&#xA;		match = Regex.Match(commandStr, @&quot;^vts(?:\s+create)?\s+new\s+par(?:ameter)?\s+(\w+)(?: with maximum value)?\s+(-?\d+)(?:, minimum value)?\s+(-?\d+)(?:, default value)?\s+(-?\d+)(?:, and notes that)?(?:\s+(.{0,255}))?$&quot;);&#xD;&#xA;		if(match.Success)&#xD;&#xA;		{&#xD;&#xA;			string parameterName = match.Groups[1].Value;&#xD;&#xA;&#xD;&#xA;			double[] _values = {&#xD;&#xA;				double.Parse(match.Groups[2].Value),&#xD;&#xA;				double.Parse(match.Groups[3].Value),&#xD;&#xA;				double.Parse(match.Groups[4].Value)&#xD;&#xA;			};&#xD;&#xA;			Array.Sort(_values);&#xD;&#xA;			string min = _values[0].ToString();&#xD;&#xA;			string max = _values[2].ToString();&#xD;&#xA;			string defaultValue = _values[1].ToString();&#xD;&#xA;&#xD;&#xA;			longCommandStr = $&quot;vts create new parameter {parameterName} with maximum value {max}, minimum value {min}, default value {defaultValue}&quot;;&#xD;&#xA;			shortCommandStr = $&quot;vts new par {parameterName} {max} {min} {defaultValue}&quot;;&#xD;&#xA;&#xD;&#xA;			parameters[&quot;parameterName&quot;] = parameterName;&#xD;&#xA;			parameters[&quot;max&quot;] = max;&#xD;&#xA;			parameters[&quot;min&quot;] = min;&#xD;&#xA;			parameters[&quot;defaultValue&quot;] = defaultValue;&#xD;&#xA;			parameters[&quot;type&quot;] = MessageTypeEnum.ParameterCreationRequest;&#xD;&#xA;&#xD;&#xA;			if(!&quot;&quot;.Equals(match.Groups[5]))//有备注&#xD;&#xA;			{&#xD;&#xA;				string explanation = match.Groups[5].Value;&#xD;&#xA;				longCommandStr = $&quot;{longCommandStr}, and notes that {explanation}&quot;;&#xD;&#xA;				shortCommandStr = $&quot;{shortCommandStr} {explanation}&quot;;&#xD;&#xA;				parameters[&quot;explanation&quot;] = explanation;&#xD;&#xA;			}&#xD;&#xA;			return CommandTypeEnum.createparameter;&#xD;&#xA;		}&#xD;&#xA;&#xD;&#xA;		/*&#xD;&#xA;			CommandTypeEnum.deleteparameter:&#xD;&#xA;				Delete custom parameters.Parameter names have to be unique, alphanumeric (no spaces allowed) and have to be between 4 and 32 characters in length.&#xD;&#xA;				删除自定义参数。参数名称必须是唯一的字母数字（不允许有空格），长度必须在4到32个字符之间。&#xD;&#xA;			eg:&#xD;&#xA;				vts delete parameter ParamBodyAngleX&#xD;&#xA;				vts del ParamBodyAngleX&#xD;&#xA;		*/&#xD;&#xA;		match = Regex.Match(commandStr, @&quot;^vts\s+del(?:ete)?(?:\s+parameter)?\s+([A-Za-z0-9]{4,32})$&quot;);&#xD;&#xA;		if(match.Success)&#xD;&#xA;		{&#xD;&#xA;			string parameterName = match.Groups[1].Value;&#xD;&#xA;			longCommandStr = $&quot;vts delete parameter {parameterName}&quot;;&#xD;&#xA;			shortCommandStr = $&quot;vts del {parameterName}&quot;;&#xD;&#xA;			parameters[&quot;parameterName&quot;] = parameterName;&#xD;&#xA;			parameters[&quot;type&quot;] = MessageTypeEnum.ParameterDeletionRequest;&#xD;&#xA;			return CommandTypeEnum.deleteparameter;&#xD;&#xA;		}&#xD;&#xA;&#xD;&#xA;		/*&#xD;&#xA;			CommandTypeEnum.createcommand:&#xD;&#xA;				You can trigger hotkeys either by their unique ID or the hotkey name (case-insensitive). &#xD;&#xA;				您可以通过热键的唯一ID或热键名称（不区分大小写）触发热键。&#xD;&#xA;			eg:&#xD;&#xA;				vts create new command that press cl when hp&lt;90 and area=九号解决方案&#xD;&#xA;				vts press cl when hp&lt;90 and area=九号解决方案&#xD;&#xA;		*/&#xD;&#xA;		match = Regex.Match(commandStr, @&quot;^vts(?:\s+create\s+new\s+command\s+that)?\s+(press|start|stop)\s+(.+)\s+when\s+(.+)$&quot;);&#xD;&#xA;		if(match.Success)&#xD;&#xA;		{&#xD;&#xA;			//校验命令(顺便创建payload)&#xD;&#xA;			string type = match.Groups[1].Value;&#xD;&#xA;			string command = match.Groups[2].Value;&#xD;&#xA;			Dictionary&lt;string, object&gt; strAndPar = CheckCmd(type, command);&#xD;&#xA;			string longCmdStr = (string)strAndPar[&quot;longCmdStr&quot;];&#xD;&#xA;			string shortCmdStr = (string)strAndPar[&quot;shortCmdStr&quot;];&#xD;&#xA;			String payload = new Message((Dictionary&lt;string, object&gt;)strAndPar[&quot;parameters&quot;]).Serialize();&#xD;&#xA;&#xD;&#xA;			//校验条件(顺便创建executer和judges)&#xD;&#xA;			string condition = match.Groups[3].Value;//传入参数&#xD;&#xA;			if(!CheckCondition(condition, payload, out string prepareConditionStr, out Judge[] judges))&#xD;&#xA;			{&#xD;&#xA;				Logger.Log($&quot;CheckConditionException {prepareConditionStr}。&quot;);&#xD;&#xA;			}&#xD;&#xA;			&#xD;&#xA;			longCommandStr = $&quot;{longCmdStr} when {prepareConditionStr}&quot;;&#xD;&#xA;			shortCommandStr = $&quot;{shortCmdStr} when {prepareConditionStr}&quot;;&#xD;&#xA;			parameters = (Dictionary&lt;string, object&gt;)strAndPar[&quot;parameters&quot;];&#xD;&#xA;			parameters[&quot;judges&quot;] = judges;&#xD;&#xA;			return CommandTypeEnum.createcommand;&#xD;&#xA;		}&#xD;&#xA;&#xD;&#xA;		/*&#xD;&#xA;			CommandTypeEnum.deletecommand:&#xD;&#xA;				Delete commands, including comands and schedulars, with parameters ranging from 0 to 999 Plugin variables have a minimum of four characters, so there is no conflict.&#xD;&#xA;				删命令,包括定时器和指令,参数是0~999的数字.插件变量最少四位字符,所以不冲突&#xD;&#xA;			eg:&#xD;&#xA;				vts delete command 1&#xD;&#xA;				vts del 1&#xD;&#xA;				vts delete command 0,1,2,3,4,5,8,9,10,11&#xD;&#xA;				vts del 0,1,2,3,4,5,8,9,10,11&#xD;&#xA;				vts delete command all&#xD;&#xA;				vts del all&#xD;&#xA;		*/&#xD;&#xA;		match = Regex.Match(commandStr, @&quot;^vts\s+del(?:ete)?(?:\s+command)?\s+([A-Za-z0-9]{1,3}(?:,[A-Za-z0-9]{1,3})*)$&quot;);&#xD;&#xA;		if(match.Success)&#xD;&#xA;		{&#xD;&#xA;			string commandIndex = match.Groups[1].Value;&#xD;&#xA;			longCommandStr = $&quot;vts delete command {commandIndex}&quot;;&#xD;&#xA;			shortCommandStr = $&quot;vts del {commandIndex}&quot;;&#xD;&#xA;			parameters[&quot;commandIndex&quot;] = commandIndex;&#xD;&#xA;			return CommandTypeEnum.deletecommand;&#xD;&#xA;		}&#xD;&#xA;&#xD;&#xA;		/*&#xD;&#xA;			CommandTypeEnum.showcommand:&#xD;&#xA;				List all commands, including commands and schedluas&#xD;&#xA;				列出所有的命令,包括指令与定时器&#xD;&#xA;			eg:&#xD;&#xA;				vts show all commands&#xD;&#xA;				vts show cmd&#xD;&#xA;		*/&#xD;&#xA;		match = Regex.Match(commandStr, @&quot;^vts\s+show(\s+all)?\s+(commands|cmd)$&quot;);&#xD;&#xA;		if(match.Success)&#xD;&#xA;		{&#xD;&#xA;			longCommandStr = &quot;vts show all commands&quot;;&#xD;&#xA;			shortCommandStr = &quot;vts show cmd&quot;;&#xD;&#xA;			return CommandTypeEnum.showcommand;&#xD;&#xA;		}&#xD;&#xA;&#xD;&#xA;		/*&#xD;&#xA;			CommandTypeEnum.executecommand:&#xD;&#xA;				Directly execute instructions, including only press/start/stop&#xD;&#xA;				直接执行指令，仅包括press/start/stop&#xD;&#xA;			eg:&#xD;&#xA;				vts execute command that press cl&#xD;&#xA;				vts press cl&#xD;&#xA;		*/&#xD;&#xA;		match = Regex.Match(commandStr, @&quot;^vts(?:\s+execute\s+command\s+that)?\s+(press|start|stop)\s+(.+)$&quot;);&#xD;&#xA;		if(match.Success)&#xD;&#xA;		{&#xD;&#xA;			string type = match.Groups[1].Value;&#xD;&#xA;			string command = match.Groups[2].Value;&#xD;&#xA;			Dictionary&lt;string, object&gt; strAndPar = CheckCmd(type, command);&#xD;&#xA;			longCommandStr = (string)strAndPar[&quot;longCmdStr&quot;];&#xD;&#xA;			shortCommandStr = (string)strAndPar[&quot;shortCmdStr&quot;];&#xD;&#xA;			parameters = (Dictionary&lt;string, object&gt;)strAndPar[&quot;parameters&quot;];&#xD;&#xA;			return CommandTypeEnum.executecommand;&#xD;&#xA;		}&#xD;&#xA;&#xD;&#xA;		/*&#xD;&#xA;			CommandTypeEnum.schedular:&#xD;&#xA;				Add a value to the timer dictionary, update it according to the log line, and send it once per second&#xD;&#xA;				给定时器的字典添加一个值，根据日志行更新，每秒发送一次&#xD;&#xA;			eg:&#xD;&#xA;				vts update schedular that set ParamBodyAngleX by hp&#xD;&#xA;				vts set ParamBodyAngleX hp&#xD;&#xA;				vts update schedular that set ParamBodyAngleX by %hp&#xD;&#xA;				vts set ParamBodyAngleX %hp&#xD;&#xA;		*/&#xD;&#xA;		match = Regex.Match(commandStr, @&quot;^vts(?:\s+update\s+schedular\s+that)?\s+set\s+([^\s]+)(?:\s+by)?\s+(?:(%)?(\w+))?$&quot;);&#xD;&#xA;		if(match.Success)&#xD;&#xA;		{&#xD;&#xA;			string key = match.Groups[1].Value;//key&#xD;&#xA;			string p = match.Groups[2].Value;//%&#xD;&#xA;			string judgeKey = match.Groups[3].Value;//judgeKey&#xD;&#xA;			parameters[&quot;key&quot;] = key;&#xD;&#xA;			parameters[&quot;p&quot;] = p;&#xD;&#xA;			parameters[&quot;judgeKey&quot;] = judgeKey;&#xD;&#xA;			longCommandStr = $&quot;vts create schedular that set {key} by {p}{judgeKey}&quot;;&#xD;&#xA;			shortCommandStr = $&quot;vts set {key} {p}{judgeKey}&quot;;&#xD;&#xA;			return CommandTypeEnum.schedular;&#xD;&#xA;		}&#xD;&#xA;&#xD;&#xA;		/*&#xD;&#xA;			CommandTypeEnum.changeLog:&#xD;&#xA;				改变日志级别，参数为一个1~3位的数字。第一位控制主要日志，第二位控制次要日志，第三位控制多数时候不用在乎的日志。参数不够三位时会在右侧补0，详见Logger类&#xD;&#xA;				0：什么也不打印&#xD;&#xA;				1：触发器日志-用户1&#xD;&#xA;				2：触发器日志-用户2&#xD;&#xA;				3：文本悬浮窗&#xD;&#xA;				9：输出内容至聊天框（需要配合ACT插件鲶鱼精邮差）&#xD;&#xA;				不知道设置成什么样子可以保持默认（312），这会将主要日志打印在聊天框，次要日志打印在触发器日志-用户1分类，不重要的日志打印在触发器日志-用户2分类&#xD;&#xA;			eg:&#xD;&#xA;				vts change log level 312&#xD;&#xA;				vts log 312&#xD;&#xA;				vts change log level 3&#xD;&#xA;				vts log 3&#xD;&#xA;		*/&#xD;&#xA;		match = Regex.Match(commandStr, @&quot;^vts(?:\s+change)?\s+log(?:\s+level)?\s+(\d{1,3})$&quot;);&#xD;&#xA;		if(match.Success)&#xD;&#xA;		{&#xD;&#xA;			string level = match.Groups[1].Value;&#xD;&#xA;			parameters[&quot;level&quot;] = level;&#xD;&#xA;			longCommandStr = $&quot;vts change log level {level}&quot;;&#xD;&#xA;			shortCommandStr = $&quot;vts log {level}&quot;;&#xD;&#xA;			return CommandTypeEnum.changeLog;&#xD;&#xA;		}&#xD;&#xA;&#xD;&#xA;		longCommandStr = &quot;vts did not match any usable commands&quot;;&#xD;&#xA;		shortCommandStr = &quot;vts did not match any usable commands&quot;;&#xD;&#xA;		parameters = null;&#xD;&#xA;		return CommandTypeEnum.donothing;&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;	//存入持久化变量&#xD;&#xA;	private static void VtsSaveCommand(string shortCommandStr)&#xD;&#xA;	{&#xD;&#xA;		int dvKey = _dv.Values.Count() + 1;&#xD;&#xA;		while(_dv.ContainsKey(dvKey.ToString()))&#xD;&#xA;		{&#xD;&#xA;			dvKey++;&#xD;&#xA;		}&#xD;&#xA;		_dv.SetValue(dvKey.ToString(), shortCommandStr);&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;	private static void VtsDeleteCommand(Dictionary&lt;string, object&gt; parameters)&#xD;&#xA;	{&#xD;&#xA;		string commandIndexString = (string)parameters[&quot;commandIndex&quot;];&#xD;&#xA;		if(commandIndexString == &quot;all&quot;) //删除全部&#xD;&#xA;		{&#xD;&#xA;			StaticHelpers.SetDictVariable(true, pluginName, new VariableDictionary());&#xD;&#xA;		}&#xD;&#xA;		else //删除部分&#xD;&#xA;		{&#xD;&#xA;			string[] commandIndexArray = commandIndexString.Split(',');&#xD;&#xA;			foreach(string commandIndex in commandIndexArray)&#xD;&#xA;			{&#xD;&#xA;			    _dv.RemoveKey(commandIndex, pluginName);&#xD;&#xA;			}&#xD;&#xA;		}&#xD;&#xA;		Init(&quot;acd&quot;);&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;	//列出所有指令与定时器,同时压缩指令序号&#xD;&#xA;	private static void VtsShowCommand()&#xD;&#xA;	{&#xD;&#xA;		string[] stringKeys = _dv.Values.Keys.ToArray();&#xD;&#xA;		int[] intKeys = new int[stringKeys.Length];&#xD;&#xA;		for(int i = 0; i &lt; stringKeys.Length; i++)&#xD;&#xA;		{&#xD;&#xA;			intKeys[i] = int.Parse(stringKeys[i]);&#xD;&#xA;		}&#xD;&#xA;		Array.Sort(intKeys);&#xD;&#xA;		Dictionary&lt;string, string&gt; newDv = new Dictionary&lt;string, string&gt;();&#xD;&#xA;		string allCommands = &quot;&quot;;&#xD;&#xA;		for (int i = 0; i &lt; intKeys.Length; i++)&#xD;&#xA;		{&#xD;&#xA;			string key = (i + 1).ToString();&#xD;&#xA;			string val = _dv.GetValue(intKeys[i].ToString()).ToString();&#xD;&#xA;			newDv.Add(key, val);&#xD;&#xA;			allCommands += $&quot;{key}→{val}\n&quot;;&#xD;&#xA;		}&#xD;&#xA;		if(intKeys.Length &gt; 0)&#xD;&#xA;		{&#xD;&#xA;			Logger.Log($&quot;have {intKeys.Length} command(s) and schedular:\n{allCommands.Substring(0, allCommands.Length - 1)}&quot;);&#xD;&#xA;		}&#xD;&#xA;		else&#xD;&#xA;		{&#xD;&#xA;			Logger.Log($&quot;have neither command nor schedular&quot;);&#xD;&#xA;		}&#xD;&#xA;		_dv = new VariableDictionary(newDv);&#xD;&#xA;		StaticHelpers.SetDictVariable(true, pluginName, _dv);&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;	//创建定时器&#xD;&#xA;	private static void VtsCreateSchedular(string shortCommandStr, Dictionary&lt;string, object&gt; parameters)&#xD;&#xA;	{&#xD;&#xA;		//先搓一个judge&#xD;&#xA;		string key = (string)parameters[&quot;key&quot;];&#xD;&#xA;		string judgeKey = (string)parameters[&quot;judgeKey&quot;];&#xD;&#xA;		JudgeMethodEnum method = (string)parameters[&quot;p&quot;] == &quot;&quot; ? JudgeMethodEnum.alltrue : JudgeMethodEnum.alltruep;&#xD;&#xA;		Judge judge = new Judge(null, 0, judgeKey, method, key);&#xD;&#xA;		//把judge放进去&#xD;&#xA;		foreach(string handleNo in AuraCanDictionary.GetHandleNosByJudgeKey(judgeKey))&#xD;&#xA;		{&#xD;&#xA;			lock(_handles)&#xD;&#xA;			{&#xD;&#xA;				if(!_handles.ContainsKey(handleNo))&#xD;&#xA;				{&#xD;&#xA;					_handles[handleNo] = new Handle(handleNo, false); //mp与Hp都不支持所有人&#xD;&#xA;				}&#xD;&#xA;				lock(_handles[handleNo])&#xD;&#xA;				{&#xD;&#xA;					_handles[handleNo].AddJudge(judge);&#xD;&#xA;				}&#xD;&#xA;			}&#xD;&#xA;		}&#xD;&#xA;		//指令持久化&#xD;&#xA;		if(shortCommandStr != &quot;&quot;)&#xD;&#xA;		{&#xD;&#xA;			VtsSaveCommand(shortCommandStr);&#xD;&#xA;		}&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;	//检测指令的判断条件是否合理,同时创建executer(执行器)与judges(判断器)&#xD;&#xA;	//true表示检测通过,out格式化后的短指令与判断器列表;false表示有问题,out异常提示&#xD;&#xA;	private static bool CheckCondition(string conditionStr, string payload, out string prepareConditionStr, out Judge[] judges)&#xD;&#xA;	{&#xD;&#xA;		// todo 得检查下有没有这个参数&#xD;&#xA;		// todo 还得查查各式是否合理&#xD;&#xA;		prepareConditionStr = conditionStr;// todo 先直接放上了&#xD;&#xA;		string[] parts = Regex.Split(conditionStr, @&quot;\s+and\s+&quot;);&#xD;&#xA;		int partsLength = parts.Length;&#xD;&#xA;		//创建executer&#xD;&#xA;		Executer executer = new Executer(partsLength, payload);&#xD;&#xA;		//创建judges&#xD;&#xA;		judges = new Judge[partsLength];&#xD;&#xA;		for(int i=0; i&lt;partsLength; i++)&#xD;&#xA;		{&#xD;&#xA;			Match match = Regex.Match(parts[i], @&quot;^(\w+)([&gt;&lt;=!]+)([\.\w]+)(%)?$&quot;);&#xD;&#xA;			string judgeKey = match.Groups[1].Value;&#xD;&#xA;			string sign = match.Groups[2].Value;&#xD;&#xA;			JudgeMethodEnum method;&#xD;&#xA;			object val;&#xD;&#xA;			if(sign.Contains(&quot;=&quot;))&#xD;&#xA;			{&#xD;&#xA;				method = sign == &quot;=&quot; ? JudgeMethodEnum.eq : JudgeMethodEnum.ne;//=和!=&#xD;&#xA;				val = match.Groups[3].Value;&#xD;&#xA;			}&#xD;&#xA;			else&#xD;&#xA;			{&#xD;&#xA;				if(!&quot;&quot;.Equals(match.Groups[4]))//匹配到了%&#xD;&#xA;				{&#xD;&#xA;					method = match.Groups[2].Value == &quot;&lt;&quot;? JudgeMethodEnum.ltp : JudgeMethodEnum.gtp;//&lt;%和&gt;%&#xD;&#xA;				}&#xD;&#xA;				else&#xD;&#xA;				{&#xD;&#xA;					method = match.Groups[2].Value == &quot;&lt;&quot;? JudgeMethodEnum.lt : JudgeMethodEnum.gt;//&lt;和&gt;&#xD;&#xA;				}&#xD;&#xA;				val = double.Parse(match.Groups[3].Value);&#xD;&#xA;			}&#xD;&#xA;			if(judgeKey == &quot;job&quot; || judgeKey == &quot;anyjob&quot; )&#xD;&#xA;			{&#xD;&#xA;				val = AuraCanDictionary.GetJobIdByJobName((string)val);&#xD;&#xA;			}&#xD;&#xA;			Judge judge = new Judge(executer, i, judgeKey, method, val);&#xD;&#xA;			bool anyFlag = judgeKey.StartsWith(&quot;any&quot;);&#xD;&#xA;			Dictionary&lt;string, Handle&gt; tempHandles = anyFlag ? _anyHandles : _handles;&#xD;&#xA;			foreach(string handleNo in AuraCanDictionary.GetHandleNosByJudgeKey(judgeKey))&#xD;&#xA;			{&#xD;&#xA;				lock(tempHandles)&#xD;&#xA;				{&#xD;&#xA;					if(!tempHandles.ContainsKey(handleNo))&#xD;&#xA;					{&#xD;&#xA;						tempHandles[handleNo] = new Handle(handleNo, anyFlag);&#xD;&#xA;					}&#xD;&#xA;					lock(tempHandles[handleNo])&#xD;&#xA;					{&#xD;&#xA;						tempHandles[handleNo].AddJudge(judge);&#xD;&#xA;					}&#xD;&#xA;				}&#xD;&#xA;			}&#xD;&#xA;			judges[i] = judge;&#xD;&#xA;		}&#xD;&#xA;		return true;&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;	//将指令处理为参数,仅press/start/stop&#xD;&#xA;	private static Dictionary&lt;string, object&gt; CheckCmd(string type, string command)&#xD;&#xA;	{&#xD;&#xA;		string longCmdStr = &quot;&quot;;&#xD;&#xA;		string shortCmdStr = &quot;&quot;;&#xD;&#xA;		Dictionary&lt;string, object&gt; strAndPar = new Dictionary&lt;string, object&gt;();&#xD;&#xA;		Dictionary&lt;string, object&gt; parameters = new Dictionary&lt;string, object&gt;();&#xD;&#xA;		if(type==&quot;press&quot;) //热键&#xD;&#xA;		{&#xD;&#xA;			longCmdStr = $&quot;vts create new command that press {command}&quot;;&#xD;&#xA;			shortCmdStr = $&quot;vts press {command}&quot;;&#xD;&#xA;			parameters[&quot;hotkeyID&quot;] = command;&#xD;&#xA;			parameters[&quot;type&quot;] = MessageTypeEnum.HotkeyTriggerRequest;&#xD;&#xA;		}&#xD;&#xA;		else if(type==&quot;start&quot;) //表达式&#xD;&#xA;		{&#xD;&#xA;			longCmdStr = $&quot;vts create new command that start {command}&quot;;&#xD;&#xA;			shortCmdStr = $&quot;vts start {command}&quot;;&#xD;&#xA;			parameters[&quot;expressionFile&quot;] = command + &quot;.exp3.json&quot;;&#xD;&#xA;			parameters[&quot;active&quot;] = true;&#xD;&#xA;			parameters[&quot;type&quot;] = MessageTypeEnum.ExpressionActivationRequest;&#xD;&#xA;		}&#xD;&#xA;		else if(type==&quot;stop&quot;) //表达式&#xD;&#xA;		{&#xD;&#xA;			longCmdStr = $&quot;vts create new command that stop {command}&quot;;&#xD;&#xA;			shortCmdStr = $&quot;vts stop {command}&quot;;&#xD;&#xA;			parameters[&quot;expressionFile&quot;] = command + &quot;.exp3.json&quot;;&#xD;&#xA;			parameters[&quot;active&quot;] = false;&#xD;&#xA;			parameters[&quot;type&quot;] = MessageTypeEnum.ExpressionActivationRequest;&#xD;&#xA;		}&#xD;&#xA;		strAndPar[&quot;longCmdStr&quot;] = longCmdStr;&#xD;&#xA;		strAndPar[&quot;shortCmdStr&quot;] = shortCmdStr;&#xD;&#xA;		strAndPar[&quot;parameters&quot;] = parameters;&#xD;&#xA;		return strAndPar;&#xD;&#xA;	}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;public static class AuraCanDictionary {&#xD;&#xA;	private static Dictionary&lt;string, string&gt; _jobDic = new List&lt;string&gt;//职业字典(key为职业名,value为十六进制职业id)&#xD;&#xA;	{&#xD;&#xA;		//逗号分割,第一个值为日志中的id,其余的值为可供输入的选项&#xD;&#xA;		//防护职业&#xD;&#xA;		&quot;13,骑士&quot;,&quot;15,战士&quot;,&quot;20,暗黑骑士,黑骑&quot;,&quot;25,绝枪战士,绝枪,枪刃&quot;,&#xD;&#xA;		&quot;01,剑术师&quot;,&quot;03,斧术师&quot;,&#xD;&#xA;		//治疗职业&#xD;&#xA;		&quot;18,白魔法师,白魔&quot;,&quot;1C,学者&quot;,&quot;21,占星术士,占星&quot;,&quot;28,贤者&quot;,&#xD;&#xA;		&quot;06,幻术师&quot;,&#xD;&#xA;		//近战职业&#xD;&#xA;		&quot;14,武僧&quot;,&quot;16,龙骑士&quot;,&quot;1E,忍者&quot;,&quot;22,武士&quot;,&quot;27,钐镰客,镰刀&quot;,&quot;29,蝰蛇剑士&quot;,&#xD;&#xA;		&quot;02,格斗家&quot;,&quot;04,枪术师&quot;,&quot;1D,双剑师&quot;,&#xD;&#xA;		//远程物理职业&#xD;&#xA;		&quot;17,吟游诗人,诗人&quot;,&quot;1F,机工士,机工&quot;,&quot;26,舞者&quot;,&#xD;&#xA;		&quot;05,弓箭手&quot;,&#xD;&#xA;		//远程魔法职业&#xD;&#xA;		&quot;19,黑魔法师,黑魔&quot;,&quot;1B,召唤师,召唤&quot;,&quot;23,赤魔法师,赤魔&quot;,&quot;2A,绘灵法师,画家&quot;,&quot;24,青魔法师,青魔&quot;,&#xD;&#xA;		&quot;07,咒术师&quot;,&quot;1A,秘术师&quot;,&#xD;&#xA;		//能工巧匠&#xD;&#xA;		&quot;08,刻木匠&quot;,&quot;09,锻铁匠&quot;,&quot;0A,铸甲匠&quot;,&quot;0B,雕金匠&quot;,&quot;0C,制革匠&quot;,&quot;0D,裁衣匠&quot;,&quot;0E,炼金术士&quot;,&quot;0F,烹调师&quot;,&#xD;&#xA;		//大地使者&#xD;&#xA;		&quot;10,采矿工&quot;,&quot;11,园艺工&quot;,&quot;12,捕鱼人&quot;&#xD;&#xA;	}.Select(keyValueString =&gt; keyValueString.Split(','))&#xD;&#xA;		.Select(parts =&gt; new { Value = parts[0], Keys = parts.Skip(1) })&#xD;&#xA;		.SelectMany(x =&gt; x.Keys.Select(key =&gt; new { Value = x.Value, Key = key }))&#xD;&#xA;		.ToDictionary(x =&gt; x.Key, x =&gt; x.Value);&#xD;&#xA;	public static string GetJobIdByJobName(string jobName)&#xD;&#xA;	{&#xD;&#xA;		return _jobDic[jobName] == null ? jobName : _jobDic[jobName];&#xD;&#xA;	}&#xD;&#xA;	private static Dictionary&lt;string, string&gt; _commandDic = new Dictionary&lt;string, string&gt;//日志字段字典&#xD;&#xA;	{&#xD;&#xA;		//handleNo,id,judgeKey,judgeKey.ToUpper()&#xD;&#xA;		//任意一人,id固定为空&#xD;&#xA;		{ &quot;anybuff&quot;, &quot;26,,1;30,,1&quot; },//&quot;任意实体&quot;被附加或移除状态&#xD;&#xA;		{ &quot;anybuffadd&quot;, &quot;26,,1&quot; },//&quot;任意实体&quot;被附加状态&#xD;&#xA;		{ &quot;anybuffremove&quot;, &quot;30,,1&quot; },//&quot;任意实体&quot;被移除状态&#xD;&#xA;		{ &quot;anyskill&quot;, &quot;21,,3;22,,3&quot; },//&quot;任意实体&quot;释放技能&#xD;&#xA;		{ &quot;anyjob&quot;, &quot;03,,2&quot; },//&quot;任意实体&quot;切换为某职业&#xD;&#xA;		//自己,id为日志行中对应字段&#xD;&#xA;		{ &quot;area&quot;, &quot;40,,2&quot; },//如&quot;九号解决方案&quot;&#xD;&#xA;		{ &quot;areasub&quot;, &quot;40,,3&quot; },&#xD;&#xA;		{ &quot;buff&quot;, &quot;26,5,1;30,5,1&quot; },//&quot;自己&quot;被附加或移除状态&#xD;&#xA;		{ &quot;buffadd&quot;, &quot;26,5,1&quot; },//&quot;自己&quot;被附加状态&#xD;&#xA;		{ &quot;buffremove&quot;, &quot;30,5,1&quot; },//&quot;自己&quot;被移除状态&#xD;&#xA;		{ &quot;hp&quot;, &quot;03,0,9,10;04,0,9,10;21,0,32,33;24,0,5,6;39,0,2,3&quot; },&#xD;&#xA;		{ &quot;job&quot;, &quot;03,0,2&quot; },//&quot;自己&quot;切换为某职业&#xD;&#xA;		{ &quot;mp&quot;, &quot;03,0,11,12;04,0,11,12;21,0,34,35;24,0,7,8;39,0,4,5&quot; },&#xD;&#xA;		{ &quot;skill&quot;, &quot;21,0,3;22,0,3&quot; },//&quot;自己&quot;释放技能&#xD;&#xA;		{ &quot;target&quot;, &quot;21,0,5&quot; }//被自己使用了技能的目标&#xD;&#xA;	};&#xD;&#xA;	public static string[] GetHandleNosByJudgeKey(string judgeKey)&#xD;&#xA;	{&#xD;&#xA;		List&lt;string&gt; noList = new List&lt;string&gt;();&#xD;&#xA;		string commandDicValue = _commandDic[judgeKey];&#xD;&#xA;		foreach(string handlePart in commandDicValue.Split(';'))&#xD;&#xA;		{&#xD;&#xA;			string handleNo = handlePart.Split(',')[0];&#xD;&#xA;			noList.Add(handleNo);&#xD;&#xA;		}&#xD;&#xA;		return noList.ToArray();&#xD;&#xA;	}&#xD;&#xA;	//通过handleNo获取实体字段为哪一列(排除any开头的字段,因为它们没有实体字段)&#xD;&#xA;	public static int GetIdIndexByHandleNo(string handleNo)&#xD;&#xA;	{&#xD;&#xA;		var commandDicValues = _commandDic&#xD;&#xA;			.Where(kv =&gt; !kv.Key.StartsWith(&quot;any&quot;))&#xD;&#xA;			.Select(kv =&gt; kv.Value);&#xD;&#xA;		foreach(string commandInfo in commandDicValues)&#xD;&#xA;		{&#xD;&#xA;			string[] handles = commandInfo.Split(';');&#xD;&#xA;			foreach(string handle in handles)&#xD;&#xA;			{&#xD;&#xA;				string[] pars = handle.Split(',');&#xD;&#xA;				if(handleNo == pars[0])&#xD;&#xA;				{&#xD;&#xA;					return pars[1] == &quot;&quot; ? -1 : int.Parse(pars[1]);&#xD;&#xA;				}&#xD;&#xA;			}&#xD;&#xA;		}&#xD;&#xA;		return -1;//-1表示日志无实体字段&#xD;&#xA;	}&#xD;&#xA;	//以judgeKey-index字典的形式返回对应日志行中哪几列数据有用&#xD;&#xA;	public static Dictionary&lt;string, int&gt; GetParsIndexByHandleNo(string handleNo)&#xD;&#xA;	{&#xD;&#xA;		Dictionary&lt;string, int&gt; parsIndex = new Dictionary&lt;string, int&gt;();&#xD;&#xA;		foreach(KeyValuePair&lt;string, string&gt; kvp in _commandDic)&#xD;&#xA;		{&#xD;&#xA;			foreach(string handlePart in kvp.Value.Split(';'))&#xD;&#xA;			{&#xD;&#xA;				string[] logInfo = handlePart.Split(',');&#xD;&#xA;				if(logInfo[0] == handleNo)&#xD;&#xA;				{&#xD;&#xA;					parsIndex.Add(kvp.Key, int.Parse(logInfo[2]));&#xD;&#xA;					if(logInfo.Length &gt; 3)&#xD;&#xA;					{&#xD;&#xA;						parsIndex.Add(kvp.Key.ToUpper(), int.Parse(logInfo[3]));&#xD;&#xA;					}&#xD;&#xA;					continue;&#xD;&#xA;				}&#xD;&#xA;			}&#xD;&#xA;		}&#xD;&#xA;		return parsIndex;&#xD;&#xA;	}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;public class Handle&#xD;&#xA;{&#xD;&#xA;	private List&lt;Judge&gt; _judges; //不同实体的判断列表&#xD;&#xA;	private Dictionary&lt;string, int&gt; _parsIndex; //参数,位于日志中第几个&#xD;&#xA;	private int _idIndex; //日志中第几个字段是实体的名字,-1表示任意实体&#xD;&#xA;	private string _handleNo; //日志行序号&#xD;&#xA;	public Handle(string handleNo, bool anyFlag) //anyFlag表示非玩家自己的信息也被判定&#xD;&#xA;	{&#xD;&#xA;		_judges = new List&lt;Judge&gt;();&#xD;&#xA;		_parsIndex = AuraCanDictionary.GetParsIndexByHandleNo(handleNo);&#xD;&#xA;		_idIndex = anyFlag ? -1 : AuraCanDictionary.GetIdIndexByHandleNo(handleNo);&#xD;&#xA;		_handleNo = handleNo;&#xD;&#xA;	}&#xD;&#xA;	public void AddJudge(Judge judge) =&gt; _judges.Add(judge);&#xD;&#xA;	public void HandleProcess(string playerId, string[] log)&#xD;&#xA;	{&#xD;&#xA;		if(_idIndex != -1 &amp;&amp; playerId != log[_idIndex])&#xD;&#xA;		{&#xD;&#xA;			return;&#xD;&#xA;		}&#xD;&#xA;		//有处理的必要才解析&#xD;&#xA;		Dictionary&lt;string, string&gt; pars = new Dictionary&lt;string, string&gt;();&#xD;&#xA;		foreach(KeyValuePair&lt;string, int&gt; kvp in _parsIndex)&#xD;&#xA;		{&#xD;&#xA;			pars.Add(kvp.Key,log[kvp.Value]);&#xD;&#xA;		}&#xD;&#xA;		string allAddPars = String.Join(&quot;,&quot;, pars.Select(kvp =&gt; $&quot;{kvp.Key} {kvp.Value}&quot;));&#xD;&#xA;		Logger.Log2($&quot;Handle{_handleNo} add par:{allAddPars}&quot;);&#xD;&#xA;		for(int i = 0; i &lt; _judges.Count; i++)&#xD;&#xA;		{&#xD;&#xA;			Logger.Log2($&quot;handleNo:{_handleNo}'s judge, {i+1}/{_judges.Count}&quot;);&#xD;&#xA;			_judges[i].JudgeProcess(pars);&#xD;&#xA;		}&#xD;&#xA;	}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;public class Judge&#xD;&#xA;{&#xD;&#xA;	private Executer _executer;&#xD;&#xA;	private int _index;//Executer数组中的索引&#xD;&#xA;	private string _key;//比较参数在handle方法参数中的key&#xD;&#xA;	private JudgeMethodEnum _method;&#xD;&#xA;	private double _numVal;&#xD;&#xA;	private string _strVal;&#xD;&#xA;	public Judge(Executer executer, int index, string judgeKey, JudgeMethodEnum method, object val)&#xD;&#xA;	{&#xD;&#xA;		_executer = executer;&#xD;&#xA;		_index = index;&#xD;&#xA;		_key = judgeKey;&#xD;&#xA;		_method = method;&#xD;&#xA;		if (val is int || val is double)&#xD;&#xA;		{&#xD;&#xA;			_numVal = (double) val;&#xD;&#xA;		}&#xD;&#xA;		else&#xD;&#xA;		{&#xD;&#xA;			_strVal = (string) val;&#xD;&#xA;		}&#xD;&#xA;	}&#xD;&#xA;	public void JudgeProcess(Dictionary&lt;string, string&gt; pars)&#xD;&#xA;	{&#xD;&#xA;		double percent;&#xD;&#xA;		switch(_method)&#xD;&#xA;		{&#xD;&#xA;			case JudgeMethodEnum.gt:&#xD;&#xA;				_executer.CheckSaveAndSend(_index, double.Parse(pars[_key]) &gt; _numVal);&#xD;&#xA;				break;&#xD;&#xA;			case JudgeMethodEnum.lt:&#xD;&#xA;				_executer.CheckSaveAndSend(_index, double.Parse(pars[_key]) &lt; _numVal);&#xD;&#xA;				break;&#xD;&#xA;			case JudgeMethodEnum.eq:&#xD;&#xA;				_executer.CheckSaveAndSend(_index, pars[_key] == _strVal);&#xD;&#xA;				break;&#xD;&#xA;			case JudgeMethodEnum.ne:&#xD;&#xA;				_executer.CheckSaveAndSend(_index, pars[_key] != _strVal);&#xD;&#xA;				break;&#xD;&#xA;			case JudgeMethodEnum.gtp://&gt;%&#xD;&#xA;				percent = double.Parse(pars[_key]) * 100 / double.Parse(pars[_key.ToUpper()]);&#xD;&#xA;				_executer.CheckSaveAndSend(_index, percent &gt; _numVal);&#xD;&#xA;				break;&#xD;&#xA;			case JudgeMethodEnum.ltp://&lt;%&#xD;&#xA;				percent = double.Parse(pars[_key]) * 100 / double.Parse(pars[_key.ToUpper()]);&#xD;&#xA;				_executer.CheckSaveAndSend(_index, percent &lt; _numVal);&#xD;&#xA;				break;&#xD;&#xA;			case JudgeMethodEnum.alltrue://更新定时器用的&#xD;&#xA;				Schedular.UpdateValue($&quot;{_strVal}&quot;, double.Parse(pars[_key]));&#xD;&#xA;				break;&#xD;&#xA;			case JudgeMethodEnum.alltruep://更新定时器%用的(范围为0~1)&#xD;&#xA;				Schedular.UpdateValue($&quot;{_strVal}&quot;, double.Parse(pars[_key]) / double.Parse(pars[_key.ToUpper()]));&#xD;&#xA;				break;&#xD;&#xA;		}&#xD;&#xA;	}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;public class Schedular // 定时器&#xD;&#xA;{&#xD;&#xA;	private static System.Threading.Timer _timer;&#xD;&#xA;	private static Dictionary&lt;string, object&gt; _setValDic;//key为自定义参数,value的格式为double&#xD;&#xA;	private static int _count;//每秒一次日志太频繁了,加个计数器&#xD;&#xA;	private static bool _sendFlag = false;//有额外发送则将值设为true,防止单周期发送超过2次&#xD;&#xA;	public Schedular()&#xD;&#xA;	{&#xD;&#xA;		StaticHelpers.Storage.TryGetValue($&quot;{pluginName}Timer&quot;, out object timerObj);&#xD;&#xA;		_timer = (System.Threading.Timer)timerObj;&#xD;&#xA;		if(_timer != null)&#xD;&#xA;		{&#xD;&#xA;			_timer.Dispose();&#xD;&#xA;		}&#xD;&#xA;		_timer = new System.Threading.Timer(SendSetMsg, null, 0, 900);&#xD;&#xA;		StaticHelpers.Storage[$&quot;{pluginName}Timer&quot;] = _timer;&#xD;&#xA;		_setValDic = new Dictionary&lt;string, object&gt;();&#xD;&#xA;	}&#xD;&#xA;	public static void StopSchedular() =&gt; _timer.Dispose();&#xD;&#xA;	public static void UpdateValue(string key, double val)&#xD;&#xA;	{&#xD;&#xA;		_setValDic[key] = val;&#xD;&#xA;		if(!_sendFlag)&#xD;&#xA;		{&#xD;&#xA;			_sendFlag = true;&#xD;&#xA;			SendSetMsg(null);//缩短响应时间,有值修改立即发送一下&#xD;&#xA;			Logger.Log2($&quot;value {key} has changed, send immediately&quot;);&#xD;&#xA;		}&#xD;&#xA;	}&#xD;&#xA;	//定时执行的方法&#xD;&#xA;	private static void SendSetMsg(object _)&#xD;&#xA;	{&#xD;&#xA;		_sendFlag = false;&#xD;&#xA;		if(_count-- == 0)&#xD;&#xA;		{&#xD;&#xA;			string allSetPars = String.Join(&quot;,&quot;, _setValDic.Select(pair =&gt; $&quot;{pair.Key}&quot;));&#xD;&#xA;			Logger.Log2($&quot;Schedular is working, param list:{allSetPars}&quot;);&#xD;&#xA;			_count = 30;//30周期打印一次日志&#xD;&#xA;		}&#xD;&#xA;		if(_setValDic.Count == 0)&#xD;&#xA;		{&#xD;&#xA;			return;&#xD;&#xA;		}&#xD;&#xA;		Dictionary&lt;string, object&gt; parameters = new Dictionary&lt;string, object&gt;();&#xD;&#xA;		parameters[&quot;mode&quot;] = &quot;set&quot;;&#xD;&#xA;		parameters[&quot;type&quot;] = MessageTypeEnum.InjectParameterDataRequest;&#xD;&#xA;		List&lt;Dictionary&lt;string, object&gt;&gt; parameterValues = new List&lt;Dictionary&lt;string, object&gt;&gt;();&#xD;&#xA;		foreach(KeyValuePair&lt;string, object&gt; kvp in _setValDic)&#xD;&#xA;		{&#xD;&#xA;			Dictionary&lt;string, object&gt; var = new Dictionary&lt;string, object&gt;();&#xD;&#xA;			var[&quot;id&quot;] = kvp.Key;&#xD;&#xA;			var[&quot;value&quot;] = kvp.Value;&#xD;&#xA;			parameterValues.Add(var);&#xD;&#xA;		}&#xD;&#xA;		parameters[&quot;parameterValues&quot;] = parameterValues;&#xD;&#xA;		Message msg = new Message(parameters);&#xD;&#xA;		AuraCanSocket.SendToVTubeStudio(msg.Serialize());&#xD;&#xA;	}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;public class Executer // 执行器&#xD;&#xA;{&#xD;&#xA;	private bool[] _flags;&#xD;&#xA;	private string _payload;&#xD;&#xA;	public Executer(int length, string payload)&#xD;&#xA;	{&#xD;&#xA;		_flags = new bool[length];&#xD;&#xA;		_payload = payload;&#xD;&#xA;	}&#xD;&#xA;	public void CheckSaveAndSend(int index, bool checkResult)&#xD;&#xA;	{&#xD;&#xA;		bool before = _flags.All(x =&gt; x);&#xD;&#xA;		_flags[index] = checkResult;&#xD;&#xA;		bool after = _flags.All(x =&gt; x);&#xD;&#xA;		Logger.Log2($&quot;before {before} after {after}, checkResult {checkResult}&quot;);&#xD;&#xA;		if(!before&amp;&amp;after)&#xD;&#xA;		{&#xD;&#xA;			AuraCanSocket.SendToVTubeStudio(_payload);&#xD;&#xA;		}&#xD;&#xA;	}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;public class Message { // 消息体&#xD;&#xA;	public string apiName { get; set; } = &quot;VTubeStudioPublicAPI&quot;;&#xD;&#xA;	public string apiVersion { get; set; } = &quot;1.0&quot;;&#xD;&#xA;	public string messageType { get; set; }&#xD;&#xA;	public Dictionary&lt;string, object&gt; data { get; set; }&#xD;&#xA;	public Message(Dictionary&lt;string, object&gt; data) {&#xD;&#xA;		this.messageType = data[&quot;type&quot;].ToString();&#xD;&#xA;		data.Remove(&quot;type&quot;);&#xD;&#xA;		this.data = data;&#xD;&#xA;	}&#xD;&#xA;	public string Serialize() =&gt; StaticHelpers.Serialize(this, false);&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;public static class AuraCanSocket { // Socket工具&#xD;&#xA;	static WebSocket ws;&#xD;&#xA;	// 发送消息&#xD;&#xA;	public static void SendToVTubeStudio(string payload)&#xD;&#xA;	{&#xD;&#xA;		if (ws == null || ws.ReadyState != WebSocketState.Open) {&#xD;&#xA;			ws = null;&#xD;&#xA;			AuraCanVTS.InitHandles();//handles清空能解决大多数问题&#xD;&#xA;			Logger.Log($&quot;WebSocket 连接未开启,初始化_handles&quot;);&#xD;&#xA;		}&#xD;&#xA;		else&#xD;&#xA;		{&#xD;&#xA;			Logger.Log3(&quot;send:&quot; + payload);&#xD;&#xA;			ws.Send(payload);&#xD;&#xA;		}&#xD;&#xA;	}&#xD;&#xA;	// 插件连接&#xD;&#xA;	public static void InitSocket() {&#xD;&#xA;		if (ws == null) {&#xD;&#xA;			WebSocket _ws = new WebSocket(wsUrl);&#xD;&#xA;			_ws.OnOpen += (_, __) =&gt; {&#xD;&#xA;				ws = (WebSocket) _ws;&#xD;&#xA;				Logger.Log2($&quot;WebSocket OnOpen&quot;);&#xD;&#xA;				Authenticate();&#xD;&#xA;			};&#xD;&#xA;			_ws.OnMessage += (_, e) =&gt; ProcessReceivedMessage(e.Data);&#xD;&#xA;			_ws.OnClose += (_, __) =&gt; {&#xD;&#xA;				ws = null;&#xD;&#xA;				Logger.Log2($&quot;WebSocket OnClose&quot;);&#xD;&#xA;				Schedular.StopSchedular();&#xD;&#xA;			};&#xD;&#xA;			_ws.ConnectAsync();&#xD;&#xA;		} else {&#xD;&#xA;			Authenticate();&#xD;&#xA;		}&#xD;&#xA;	}&#xD;&#xA;	// 认证&#xD;&#xA;	private static void Authenticate() {&#xD;&#xA;		string token = StaticHelpers.GetScalarVariable(true, $&quot;{pluginName}Token&quot;) ?? &quot;&quot;;&#xD;&#xA;		MessageTypeEnum type;&#xD;&#xA;		Dictionary&lt;string, object&gt; parameters = new Dictionary&lt;string, object&gt;();&#xD;&#xA;		if (token == &quot;&quot;) {&#xD;&#xA;			type = MessageTypeEnum.AuthenticationTokenRequest;&#xD;&#xA;			parameters[&quot;pluginIcon&quot;] = &quot;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&quot;;&#xD;&#xA;		} else {&#xD;&#xA;			type = MessageTypeEnum.AuthenticationRequest;&#xD;&#xA;			parameters[&quot;authenticationToken&quot;] = token;&#xD;&#xA;		}&#xD;&#xA;		parameters[&quot;pluginName&quot;] = pluginName + &quot; &quot; + version;&#xD;&#xA;		parameters[&quot;pluginDeveloper&quot;] = developer;&#xD;&#xA;		parameters[&quot;type&quot;] = type;&#xD;&#xA;		string payload = new Message(parameters).Serialize();&#xD;&#xA;		SendToVTubeStudio(payload);&#xD;&#xA;	}&#xD;&#xA;	// 收到消息时执行的方法&#xD;&#xA;	private static void ProcessReceivedMessage(string json) {&#xD;&#xA;		Logger.Log3($&quot;receive:{json}&quot;);&#xD;&#xA;		if (json.Contains(&quot;errorID&quot;)) {&#xD;&#xA;			string errorId = GetValueFromJson(json, &quot;errorID&quot;);&#xD;&#xA;			if (errorId == &quot;50&quot; || errorId == &quot;8&quot;) {&#xD;&#xA;				StaticHelpers.SetScalarVariable(true, $&quot;{pluginName}Token&quot;, &quot;&quot;);&#xD;&#xA;			}&#xD;&#xA;			Logger.Log($&quot;error:{json}&quot;);&#xD;&#xA;		}&#xD;&#xA;		if (json.Contains(&quot;authenticationToken&quot;)) {&#xD;&#xA;			string token = GetValueFromJson(json, &quot;authenticationToken&quot;);&#xD;&#xA;			Logger.Log($&quot;get and saved token&quot;);&#xD;&#xA;			StaticHelpers.SetScalarVariable(true, $&quot;{pluginName}Token&quot;, token);&#xD;&#xA;			Authenticate();&#xD;&#xA;		} else if (json.Contains(&quot;authenticated&quot;)) {&#xD;&#xA;			if (GetValueFromJson(json, &quot;authenticated&quot;) == &quot;false&quot;) {&#xD;&#xA;				Logger.Log($&quot;lost token and try to re authenticate&quot;);&#xD;&#xA;				StaticHelpers.SetScalarVariable(true, $&quot;{pluginName}Token&quot;, &quot;&quot;);&#xD;&#xA;				Authenticate();&#xD;&#xA;			}&#xD;&#xA;		}&#xD;&#xA;	}&#xD;&#xA;	// 获取json每个字段的值&#xD;&#xA;	private static string GetValueFromJson(string jsonString, string key) {&#xD;&#xA;		return new Regex(&quot;\&quot;&quot; + key + &quot;\&quot;:\&quot;?([^\&quot;,}]*)&quot;).Match(jsonString).Groups[1].Value;&#xD;&#xA;	}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;public enum CommandTypeEnum // AuraCanVTS命令&#xD;&#xA;{&#xD;&#xA;	createparameter, //创建参数&#xD;&#xA;	deleteparameter, //删除参数&#xD;&#xA;	createcommand,//创建命令&#xD;&#xA;	deletecommand, //删除命令&#xD;&#xA;	showcommand, //列出已创建的命令&#xD;&#xA;	executecommand, //立刻执行&#xD;&#xA;	schedular, //调度器&#xD;&#xA;	changeLog, //修改日志打印方式&#xD;&#xA;	donothing //啥都不干(无匹配正则)&#xD;&#xA;	//通过回调直接触发不使用枚举&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;public enum MessageTypeEnum { // VTube Studio命令&#xD;&#xA;	AuthenticationRequest, //身份验证1&#xD;&#xA;	AuthenticationTokenRequest, //身份验证2&#xD;&#xA;	ParameterCreationRequest, //添加新的自定义参数&#xD;&#xA;	ParameterDeletionRequest, //删除自定义参数&#xD;&#xA;	InjectParameterDataRequest, //输入默认或自定义参数的数据&#xD;&#xA;	HotkeyTriggerRequest, //请求执行热键&#xD;&#xA;	ExpressionActivationRequest //请求激活/停用表达式&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;public enum JudgeMethodEnum // 指令中可用的比较方法&#xD;&#xA;{&#xD;&#xA;	gt, //&gt;&#xD;&#xA;	lt, //&lt;&#xD;&#xA;	eq, //=&#xD;&#xA;	ne, //!=&#xD;&#xA;	gtp, //&gt;%&#xD;&#xA;	ltp, //&lt;%&#xD;&#xA;	alltrue, //一直为真,用于更新数据&#xD;&#xA;	alltruep //一直为真,用于更新数据%&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;//日志打印&#xD;&#xA;public static class Logger&#xD;&#xA;{&#xD;&#xA;	private static ILogger _logger;//重要信息(例如报错和关键提示信息)&#xD;&#xA;	private static ILogger _logger2;//不太重要的信息(例如非关键提示信息)&#xD;&#xA;	private static ILogger _logger3;//完全不重要的信息(发送的和接收的)&#xD;&#xA;	public static void Log(string msg) =&gt; _logger.Log($&quot;{pluginName}{version} {msg}&quot;);&#xD;&#xA;	public static void Log2(string msg) =&gt; _logger2.Log($&quot;{pluginName}{version} {msg}&quot;);&#xD;&#xA;	public static void Log3(string msg) =&gt; _logger3.Log($&quot;{pluginName}{version} {msg}&quot;);&#xD;&#xA;	private static NoneLogger _noneLogger = new NoneLogger();//啥也不干&#xD;&#xA;	private static TriggernometryLogger _triggernometryLogger = new TriggernometryLogger();//用户日志1&#xD;&#xA;	private static TriggernometryLogger2 _triggernometryLogger2 = new TriggernometryLogger2();//用户日志2&#xD;&#xA;	private static TextAuraLogger _textAuraLogger = new TextAuraLogger();//文本悬浮窗&#xD;&#xA;	private static PostNamazuLogger _postNamazuLogger = new PostNamazuLogger();//鲶鱼精&#xD;&#xA;	private static readonly Dictionary&lt;string, ILogger&gt; loggers = new()&#xD;&#xA;	{&#xD;&#xA;		[&quot;0&quot;] = _noneLogger, // 啥也不干&#xD;&#xA;		[&quot;1&quot;] = _triggernometryLogger, // 用户日志1&#xD;&#xA;		[&quot;2&quot;] = _triggernometryLogger2, // 用户日志2&#xD;&#xA;		[&quot;3&quot;] = _textAuraLogger, // 文本悬浮窗&#xD;&#xA;		[&quot;9&quot;] = _postNamazuLogger // 鲶鱼精邮差&#xD;&#xA;	};&#xD;&#xA;	public static void SetLogger(string level)//数字绝对值越大日志越多,负数区间分给鲶鱼精邮差&#xD;&#xA;	{&#xD;&#xA;		_textAuraLogger.Destroy(); // 清空一下&#xD;&#xA;		StaticHelpers.SetScalarVariable(true, $&quot;{pluginName}LogLevel&quot;, level);&#xD;&#xA;		level = level.PadRight(3, '0');&#xD;&#xA;		_logger = loggers[level[0].ToString()];&#xD;&#xA;		_logger2 = loggers[level[1].ToString()];&#xD;&#xA;		_logger3 = loggers[level[2].ToString()];&#xD;&#xA;	}&#xD;&#xA;}&#xD;&#xA;public interface ILogger&#xD;&#xA;{&#xD;&#xA;	void Log(string msg);&#xD;&#xA;}&#xD;&#xA;public class NoneLogger : ILogger//啥都不干&#xD;&#xA;{&#xD;&#xA;	public void Log(string msg) {}&#xD;&#xA;}&#xD;&#xA;public class TriggernometryLogger : ILogger//日志行(高级触发器用户日志)&#xD;&#xA;{&#xD;&#xA;	public void Log(string msg) =&gt; StaticHelpers.Log(RealPlugin.DebugLevelEnum.Custom, msg);&#xD;&#xA;}&#xD;&#xA;public class TriggernometryLogger2 : ILogger//日志行(高级触发器用户2日志)&#xD;&#xA;{&#xD;&#xA;	public void Log(string msg) =&gt; StaticHelpers.Log(RealPlugin.DebugLevelEnum.Custom2, msg);&#xD;&#xA;}&#xD;&#xA;public class TextAuraLogger : ILogger//文本悬浮窗&#xD;&#xA;{&#xD;&#xA;	private static Triggernometry.Action _logAuraAction;&#xD;&#xA;	private static Triggernometry.Context _ctx;&#xD;&#xA;	private static Triggernometry.Trigger _trig;&#xD;&#xA;	private static ConcurrentQueue&lt;string&gt; _msgQueue;&#xD;&#xA;	public TextAuraLogger()&#xD;&#xA;	{&#xD;&#xA;		_logAuraAction = new Triggernometry.Action();&#xD;&#xA;		_logAuraAction.ActionType = Triggernometry.Action.ActionTypeEnum.TextAura.ToString();&#xD;&#xA;		_logAuraAction.AuraOp = Triggernometry.Action.AuraOpEnum.ActivateAura.ToString();&#xD;&#xA;		_logAuraAction.TextAuraName = pluginName;&#xD;&#xA;		_logAuraAction.TextAuraAlignment = &quot;TopLeft&quot;;&#xD;&#xA;		_logAuraAction.TextAuraFontSize = &quot;15&quot;;&#xD;&#xA;		_logAuraAction.TextAuraXIniExpression = &quot;0&quot;;&#xD;&#xA;		_logAuraAction.TextAuraYIniExpression = &quot;0&quot;;&#xD;&#xA;		_logAuraAction.TextAuraWIniExpression = &quot;1000&quot;;&#xD;&#xA;		_logAuraAction.TextAuraHIniExpression = &quot;1500&quot;;&#xD;&#xA;		_logAuraAction.TextAuraOIniExpression = &quot;100&quot;;&#xD;&#xA;		_logAuraAction.TextAuraFontName = &quot;Microsoft YaHei&quot;;&#xD;&#xA;		_logAuraAction.TextAuraOutline = &quot;#0080FF&quot;;&#xD;&#xA;		_logAuraAction.TextAuraForeground = &quot;White&quot;;&#xD;&#xA;		_ctx = new Context();&#xD;&#xA;		_trig = new Trigger();&#xD;&#xA;		_trig.Name = pluginName;&#xD;&#xA;		_msgQueue = new ConcurrentQueue&lt;string&gt;();&#xD;&#xA;	}&#xD;&#xA;	public void Log(string msg)&#xD;&#xA;	{&#xD;&#xA;		_msgQueue.Enqueue(msg);&#xD;&#xA;		if (_msgQueue.Count &gt; 30)&#xD;&#xA;		{&#xD;&#xA;			_msgQueue.TryDequeue(out string _);&#xD;&#xA;		}&#xD;&#xA;		_logAuraAction.TextAuraExpression = string.Join(&quot;\n&quot;, _msgQueue);&#xD;&#xA;		Triggernometry.RealPlugin.plug.QueueAction(_ctx, _trig, null, _logAuraAction, System.DateTime.Now, false);&#xD;&#xA;	}&#xD;&#xA;	public void Destroy()&#xD;&#xA;	{&#xD;&#xA;		_msgQueue = new ConcurrentQueue&lt;string&gt;();&#xD;&#xA;		_logAuraAction.TextAuraExpression = &quot;&quot;;&#xD;&#xA;		Triggernometry.RealPlugin.plug.QueueAction(_ctx, _trig, null, _logAuraAction, System.DateTime.Now, false);&#xD;&#xA;	}&#xD;&#xA;}&#xD;&#xA;public class PostNamazuLogger : ILogger//鲶鱼精邮差&#xD;&#xA;{&#xD;&#xA;	public void Log(string msg) =&gt; Triggernometry.RealPlugin.plug.InvokeNamedCallback(&quot;command&quot;, &quot;/e &quot; + msg);&#xD;&#xA;}" SoundRouting="None" TTSRouting="None" ActionType="ExecuteScript">
            <Condition Enabled="false" Grouping="Or" />
          </Action>
        </Actions>
        <Condition Enabled="false" Grouping="Or" />
      </Trigger>
      <Trigger Enabled="true" Source="FFXIVNetwork" Name="日志处理" Id="d6a4de60-0d76-4052-98d0-f9f2081cc994" RegularExpression="^(?&lt;log&gt;[0-9]{2}\|.*)">
        <Actions>
          <Action OrderNumber="1" NamedCallbackName="AuraCanVTS" NamedCallbackParam="${log}" SoundRouting="None" TTSRouting="None" ActionType="NamedCallback">
            <Condition Enabled="false" Grouping="Or" />
          </Action>
        </Actions>
        <Condition Enabled="false" Grouping="Or" />
      </Trigger>
    </Triggers>
  </ExportedFolder>
</TriggernometryExport>